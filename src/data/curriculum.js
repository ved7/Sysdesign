const buildTopicContent = ({ overview, learn = [], apply = [] }) => `
  <h3>Overview</h3>
  <p>${overview}</p>
  ${learn.length ? `<h3>What to learn</h3><ul>${learn.map((item) => `<li>${item}</li>`).join('')}</ul>` : ''}
  ${apply.length ? `<h3>How to apply it in interviews</h3><ul>${apply.map((item) => `<li>${item}</li>`).join('')}</ul>` : ''}
`;

const topic = ({ id, title, description, difficulty = 'Intermediate', overview, learn, apply }) => ({
  id,
  title,
  description,
  difficulty,
  content: buildTopicContent({ overview: overview ?? description, learn, apply }),
});

export const curriculum = [
  {
    id: 'start-here',
    title: 'System Design Topics: Start Here',
    description: 'Build your foundation first, then expand breadth and depth with an intentional roadmap.',
    topics: [
      topic({
        id: 'scalability-video-lecture',
        title: 'Step 1: Review the Scalability Video Lecture',
        difficulty: 'Basic',
        description: 'Watch a complete scalability primer before diving into individual patterns.',
        overview:
          'Start with one end-to-end scalability lecture that explains vertical vs horizontal scaling, bottlenecks, load distribution, and data partitioning. The goal is to build a mental map before memorizing tools.',
        learn: [
          'Identify common bottlenecks: CPU, memory, disk I/O, network, and lock contention.',
          'Understand why stateless services are easier to scale than stateful services.',
          'Connect core ideas: queues, caches, replication, and sharding as scale levers.',
        ],
        apply: [
          'Begin interview answers with bottleneck assumptions, not technologies.',
          'Use throughput and latency targets to justify architecture choices.',
        ],
      }),
      topic({
        id: 'scalability-article',
        title: 'Step 2: Review the Scalability Article',
        difficulty: 'Basic',
        description: 'Reinforce concepts with a written walkthrough and architecture diagrams.',
        overview:
          'Read a high-quality scalability article after the video lecture. Writing and diagrams improve retention and help you structure system design answers in a clean narrative.',
        learn: [
          'Capture definitions for latency, throughput, availability, consistency, and durability.',
          'Trace request flow from client to edge, app tier, cache, database, and async workers.',
          'Record 3-5 architecture templates you can reuse in interviews.',
        ],
        apply: [
          'Use the same structure in interviews: requirements, estimation, APIs, data model, architecture, and trade-offs.',
        ],
      }),
      topic({
        id: 'next-steps',
        title: 'Next Steps',
        difficulty: 'Basic',
        description: 'Move from fundamentals to deeper distributed systems patterns systematically.',
        overview:
          'After completing the two scalability resources, continue through trade-offs, traffic management, data systems, caching, async processing, and communication protocols.',
        learn: [
          'Study topics in sequence instead of random order to avoid conceptual gaps.',
          'Practice one interview problem per topic cluster to build transfer skills.',
        ],
        apply: [
          'Create a revision loop: learn concept, solve one problem, write one-page summary.',
        ],
      }),
    ],
  },
  {
    id: 'core-tradeoffs',
    title: 'Core Trade-Offs',
    description: 'The decision framework behind nearly every system design choice.',
    topics: [
      topic({
        id: 'performance-vs-scalability',
        title: 'Performance vs Scalability',
        difficulty: 'Basic',
        description: 'Performance is speed now; scalability is sustained speed as load grows.',
        overview: 'Performance optimization makes a single user experience faster. Scalability ensures the system remains fast when millions of users arrive simultaneously. Understanding this distinction prevents premature optimization and architectural debt.',
        learn: [
          'Measure performance with latency metrics and scalability with load curves.',
          'Recognize optimizations that improve one-user speed but hurt growth.',
          'Understand Amdahl\'s Law: theoretical speedup is limited by the sequential portion of the workload.',
          'Identify when to optimize code (performance) vs when to add servers (scalability).',
        ],
        apply: [
          'In interviews, separate immediate optimization from long-term scaling strategy.',
          'Example: Caching improves performance; sharding improves scalability. Use both but know which solves which problem.',
        ],
      }),
      topic({
        id: 'latency-vs-throughput',
        title: 'Latency vs Throughput',
        difficulty: 'Basic',
        description: 'Latency is time per request; throughput is requests handled per unit time.',
        overview: 'Low latency means fast response for one user. High throughput means serving many users efficiently. These often conflict: batching improves throughput but adds latency. Streaming improves latency but reduces throughput.',
        learn: [
          'Understand p50, p95, p99 latency instead of averages only.',
          'See how batching improves throughput but can increase tail latency.',
          'Learn about Little\'s Law: L = λ × W (concurrency = throughput × latency).',
          'Identify head-of-line blocking and how it affects both metrics.',
        ],
        apply: [
          'Discuss SLOs with both tail latency and throughput objectives.',
          'Design for p99 latency targets, not averages, because outliers ruin user experience.',
        ],
      }),
      topic({
        id: 'availability-vs-consistency',
        title: 'Availability vs Consistency',
        difficulty: 'Basic',
        description: 'Distributed systems often choose one under partitions and failures.',
        overview: 'When networks fail, you cannot have both perfect availability and perfect consistency. Banks choose consistency (CP); social media chooses availability (AP). Your choice depends on business impact of stale data vs downtime.',
        learn: [
          'Map business domains to consistency requirements: payments vs social feeds.',
          'Learn how stale reads can improve uptime but affect correctness.',
          'Understand the spectrum: strong → session → bounded staleness → eventual consistency.',
          'Study PACELC theorem: if partitioned, choose availability or consistency; else, choose latency or consistency.',
        ],
        apply: [
          'State where your design can tolerate stale data and where it cannot.',
          'Design hybrid systems: strong consistency for inventory, eventual for recommendations.',
        ],
      }),
      topic({
        id: 'cap-theorem',
        title: 'CAP Theorem',
        difficulty: 'Intermediate',
        description: 'In partitioned distributed systems, you prioritize consistency or availability.',
        overview: 'Eric Brewer\'s CAP theorem states that during a network partition, a distributed system must choose between Consistency (linearizability) and Availability (every request receives a response). Partition tolerance is mandatory in distributed systems.',
        learn: [
          'Interpret CAP in terms of network partitions, not normal operation.',
          'Avoid the common mistake of claiming CA for distributed systems.',
          'Understand that CAP is a spectrum, not binary: tunable consistency in Dynamo, Cassandra.',
          'Study real-world examples: ZooKeeper (CP), Cassandra (AP), MongoDB (configurable).',
        ],
        apply: [
          'Use CAP to justify database and API behavior under failures.',
          'When interviewer asks "How does your system handle failures?" reference CAP choice explicitly.',
        ],
      }),
      topic({
        id: 'cp-consistency-partition-tolerance',
        title: 'CP - Consistency and Partition Tolerance',
        difficulty: 'Intermediate',
        description: 'Prefer correct data even if some requests must fail during partitions.',
        overview: 'CP systems sacrifice availability during partitions to maintain consistency. If nodes cannot communicate, the system returns errors rather than stale data. Essential for financial transactions, inventory, and configuration management.',
        learn: [
          'Techniques: quorum writes, leader election, and strict ordering.',
          'Costs: reduced availability and higher latency under failure.',
          'Consensus algorithms: Paxos, Raft, Zab (ZooKeeper Atomic Broadcast).',
          'Implementation: Two-phase commit, distributed locks, serializable isolation.',
        ],
        apply: [
          'Use CP reasoning for money movement, inventory, and authorization systems.',
          'Design for graceful degradation: read-only mode during partition rather than complete downtime.',
        ],
      }),
      topic({
        id: 'ap-availability-partition-tolerance',
        title: 'AP - Availability and Partition Tolerance',
        difficulty: 'Intermediate',
        description: 'Keep serving traffic with potentially stale or divergent data.',
        overview: 'AP systems remain available during partitions, accepting that different nodes may have divergent states. Data converges eventually when partition heals. Suitable for social feeds, analytics, and recommendations where temporary inconsistency is acceptable.',
        learn: [
          'Techniques: eventual consistency, async reconciliation, conflict resolution.',
          'Costs: temporary inconsistency and harder client semantics.',
          'Conflict resolution strategies: last-write-wins (LWW), vector clocks, CRDTs.',
          'Hinted handoff and read repair mechanisms in Dynamo-style databases.',
        ],
        apply: [
          'Use AP approaches for timelines, analytics, and recommendation feeds.',
          'Design idempotent operations so duplicate requests during partitions are safe.',
        ],
      }),
    ],
  },
  {
    id: 'consistency-availability-patterns',
    title: 'Consistency and Availability Patterns',
    description: 'Operational patterns that define user experience under failure.',
    topics: [
      topic({
        id: 'consistency-patterns',
        title: 'Consistency Patterns',
        difficulty: 'Basic',
        description: 'Pattern families that control read and write correctness guarantees.',
        overview: 'Consistency patterns define what users see after writes complete. They range from strict linearizability (everyone sees the same order) to eventual consistency (order doesn\'t matter, convergence does). Choose based on user expectations and business rules.',
        learn: [
          'Map consistency requirements to user-facing operations.',
          'Choose between strict, eventual, or session-level guarantees.',
          'Understand read-your-own-writes, monotonic reads, and bounded staleness.',
          'Learn about causal consistency: preserving happens-before relationships without global ordering.',
        ],
        apply: [
          'Implement session affinity for read-your-own-writes consistency in AP systems.',
          'Use version vectors to detect and resolve conflicts in distributed writes.',
        ],
      }),
      topic({
        id: 'availability-patterns',
        title: 'Availability Patterns',
        difficulty: 'Basic',
        description: 'Design patterns that keep systems responsive during failures.',
        overview: 'Availability patterns ensure systems remain operational despite component failures. They include redundancy, health monitoring, automatic failover, and graceful degradation. The goal is to minimize Mean Time To Repair (MTTR) and maximize uptime.',
        learn: [
          'Use redundancy, health checks, failover, and graceful degradation.',
          'Quantify availability choices using SLA and error budget targets.',
          'Understand active-active vs active-passive deployment models.',
          'Study chaos engineering: intentionally injecting failures to test resilience.',
        ],
        apply: [
          'Design health checks at multiple levels: load balancer (TCP), service (HTTP), and deep (dependency checks).',
          'Implement circuit breakers to prevent cascade failures when dependencies fail.',
        ],
      }),
      topic({
        id: 'weak-consistency',
        title: 'Weak Consistency',
        difficulty: 'Intermediate',
        description: 'No guarantee reads immediately reflect recent writes.',
        overview: 'Weak consistency offers no promises about staleness. Reads may return data from any point in the past. Used in DNS, memcached without replication, and some analytics systems. Simple but requires careful client handling.',
        learn: [
          'Understand where weak guarantees are acceptable and cost-efficient.',
          'Design client UX to handle delayed convergence safely.',
          'Recognize that weak consistency maximizes performance and availability.',
          'Study use cases: DNS propagation, CDN cache, feature flags.',
        ],
        apply: [
          'Use weak consistency for non-critical configuration that updates rarely.',
          'Implement client-side polling or refresh buttons to handle stale data explicitly.',
        ],
      }),
      topic({
        id: 'eventual-consistency',
        title: 'Eventual Consistency',
        difficulty: 'Intermediate',
        description: 'Replicas converge over time if no new writes continue indefinitely.',
        overview: 'Eventual consistency guarantees that if no new updates are made, eventually all replicas will agree. During convergence, different users may see different values. The most practical consistency model for distributed systems at scale.',
        learn: [
          'Use versioning and idempotency to avoid update loss.',
          'Plan reconciliation jobs and conflict resolution policies.',
          'Understand anti-entropy mechanisms: Merkle trees for efficient comparison.',
          'Study BASE semantics: Basically Available, Soft state, Eventual consistency.',
        ],
        apply: [
          'Implement vector clocks or logical timestamps to track causality.',
          'Design compensating transactions for business operations that cannot tolerate eventual consistency.',
        ],
      }),
      topic({
        id: 'strong-consistency',
        title: 'Strong Consistency',
        difficulty: 'Intermediate',
        description: 'Reads always return the latest committed value.',
        overview: 'Strong consistency (linearizability) ensures every read sees the most recent write, as if there were only one copy of data. Requires coordination, increasing latency and reducing availability. Implemented via consensus protocols or single-leader replication.',
        learn: [
          'Understand leader-based replication and quorum requirements.',
          'Model failure behavior and timeout strategy for strict semantics.',
          'Study Raft consensus: leader election, log replication, safety guarantees.',
          'Learn about the FLP impossibility: no deterministic consensus in async systems with even one faulty process.',
        ],
        apply: [
          'Use strong consistency for account balances, inventory counts, and unique username allocation.',
          'Implement distributed transactions using Saga pattern or 2PC when spanning multiple services.',
        ],
      }),
      topic({
        id: 'fail-over',
        title: 'Fail-over',
        difficulty: 'Intermediate',
        description: 'Automatically move traffic to healthy instances during outages.',
        overview: 'Fail-over redirects traffic from failed primary to standby replicas. Can be automatic (faster, risk of split-brain) or manual (slower, safer). Critical for achieving high availability (99.99%+).',
        learn: [
          'Design health checks, timeout thresholds, and promotion logic.',
          'Differentiate cold, warm, and hot standby setups.',
          'Understand split-brain problem and fencing mechanisms (STONITH).',
          'Study leader election algorithms: Bully algorithm, ZooKeeper ephemeral nodes.',
        ],
        apply: [
          'Implement automatic fail-over with conservative health check thresholds to avoid flapping.',
          'Use data center redundancy with DNS-based or anycast routing for geographic fail-over.',
        ],
      }),
      topic({
        id: 'replication',
        title: 'Replication',
        difficulty: 'Intermediate',
        description: 'Maintain data copies for resilience and read scalability.',
        overview: 'Replication creates redundant data copies across nodes or data centers. Synchronous replication ensures consistency but adds latency; asynchronous replication improves performance but risks data loss. Foundation for both availability and read scaling.',
        learn: [
          'Compare synchronous and asynchronous replication models.',
          'Track replication lag and understand consistency impact.',
          'Study replication topologies: single-leader, multi-leader, leaderless (Dynamo-style).',
          'Understand quorum reads/writes: R + W > N for strong consistency.',
        ],
        apply: [
          'Use read replicas for analytics and reporting to offload primary database.',
          'Implement semi-synchronous replication for critical data: wait for one replica acknowledgment.',
        ],
      }),
      topic({
        id: 'availability-in-numbers',
        title: 'Availability in Numbers',
        difficulty: 'Basic',
        description: 'Translate SLA targets into downtime budgets and architecture requirements.',
        overview: 'Availability is measured in "nines": 99.9% (three nines) allows 8.76 hours downtime/year; 99.999% (five nines) allows only 5.26 minutes. Each nine increases cost exponentially. Design redundancy based on business requirements, not perfection.',
        learn: [
          'Relate 99.9%, 99.99%, and 99.999% to annual/monthly downtime.',
          'Design redundancy based on acceptable outage windows.',
          'Calculate composite availability: if Service A (99.9%) depends on Service B (99.9%), combined availability is 99.8%.',
          'Understand error budgets: balance reliability against feature velocity.',
        ],
        apply: [
          'Negotiate realistic SLAs based on dependency SLAs and architectural constraints.',
          'Use chaos engineering to verify that redundancy actually works (not just configured).',
        ],
      }),
    ],
  },
  {
    id: 'traffic-edge',
    title: 'Traffic Management and Edge Delivery',
    description: 'How requests reach your system quickly and reliably.',
    topics: [
      topic({
        id: 'domain-name-system',
        title: 'Domain Name System',
        difficulty: 'Basic',
        description: 'DNS maps domain names to IP addresses through hierarchical resolution.',
        overview: 'DNS is the internet\'s phonebook, translating human-readable domains to IP addresses. Hierarchical and distributed, it uses caching extensively. Critical for load distribution, failover, and geographic routing.',
        learn: [
          'Understand recursive resolvers, authoritative servers, and TTL.',
          'Know DNS-based routing and failure implications.',
          'Study record types: A, AAAA, CNAME, MX, NS, TXT.',
          'Learn about DNS propagation delays and negative caching.',
        ],
        apply: [
          'Use short TTLs (30-300 seconds) during migrations for quick cutover.',
          'Implement health-checked DNS with multiple A records for basic load distribution.',
        ],
      }),
      topic({
        id: 'content-delivery-network',
        title: 'Content Delivery Network',
        difficulty: 'Basic',
        description: 'CDNs cache and serve content close to users to reduce latency.',
        overview: 'CDNs place edge servers worldwide, caching static content near users. Reduce origin load, improve latency, and absorb DDoS attacks. Modern CDNs also offer edge compute (Cloudflare Workers, Lambda@Edge) for dynamic content.',
        learn: [
          'Differentiate static asset caching from dynamic edge compute.',
          'Use cache-control headers effectively with CDN behavior.',
          'Understand cache hit ratio, origin shield, and tiered caching.',
          'Study purge mechanisms: single URL, wildcard, and soft purge.',
        ],
        apply: [
          'Cache immutable assets with long TTLs and versioned filenames (app.v123.js).',
          'Use stale-while-revalidate to serve cached content during origin outages.',
        ],
      }),
      topic({
        id: 'push-cdns',
        title: 'Push CDNs',
        difficulty: 'Intermediate',
        description: 'Origin proactively uploads content to CDN storage.',
        overview: 'Push CDNs require content to be uploaded to CDN storage before user requests. Suitable for large files, software distributions, and video-on-demand. Predictable performance but requires explicit upload management.',
        learn: [
          'Understand predictable release workflows and invalidation strategy.',
          'Evaluate operational overhead vs deterministic edge availability.',
          'Compare with origin storage: S3, GCS, Azure Blob with CDN frontend.',
          'Study upload optimization: multipart uploads, checksums, and consistency.',
        ],
        apply: [
          'Use push CDNs for large video files where pull latency would hurt user experience.',
          'Implement automated upload pipelines with checksum verification.',
        ],
      }),
      topic({
        id: 'pull-cdns',
        title: 'Pull CDNs',
        difficulty: 'Intermediate',
        description: 'CDN fetches content from origin on cache miss and stores it.',
        overview: 'Pull CDNs fetch content on-demand when first requested, then cache for subsequent requests. Easier to manage (no explicit uploads) but first user experiences origin latency. Most common CDN model.',
        learn: [
          'Design cache key strategy and expiration policy.',
          'Handle cache stampede and origin protection.',
          'Understand cache-busting techniques: query strings, headers, and versioning.',
          'Study Vary header for content negotiation (Accept-Encoding, Accept-Language).',
        ],
        apply: [
          'Use cache keys that exclude user-specific cookies for static assets.',
          'Implement request coalescing (collapsed forwarding) to prevent stampede on popular cache misses.',
        ],
      }),
      topic({
        id: 'load-balancing',
        title: 'Load Balancer',
        difficulty: 'Basic',
        description: 'Distribute traffic across servers to improve reliability and utilization.',
        overview: 'Load balancers distribute incoming requests across backend servers. Operate at Layer 4 (transport) or Layer 7 (application). Provide health checking, SSL termination, and session persistence. Essential for horizontal scaling.',
        learn: [
          'Apply round robin, least connections, and weighted routing.',
          'Use health checks and circuit breaking to isolate bad nodes.',
          'Understand session affinity (sticky sessions) and its pitfalls.',
          'Study load balancer types: hardware (F5), software (NGINX, HAProxy), cloud (ALB, NLB).',
        ],
        apply: [
          'Explain how load balancing protects both latency and availability.',
          'Use least-connections algorithm for long-lived connections (WebSockets) rather than round-robin.',
        ],
      }),
      topic({
        id: 'active-passive',
        title: 'Active-Passive',
        difficulty: 'Intermediate',
        description: 'Primary instance serves traffic; standby takes over on failure.',
        overview: 'Active-passive redundancy maintains a standby replica that does not serve traffic until primary fails. Simpler consistency (only one active writer) but slower failover and wasted capacity. Common for databases and stateful services.',
        learn: [
          'Model failover RTO/RPO and split-brain prevention.',
          'Automate promotion and rollback safely.',
          'Understand replication lag impact on RPO (data loss window).',
          'Study fencing mechanisms: STONITH (Shoot The Other Node In The Head).',
        ],
        apply: [
          'Use active-passive for relational databases where multi-master is complex.',
          'Implement automated failover with conservative health checks to avoid false positives.',
        ],
      }),
      topic({
        id: 'active-active',
        title: 'Active-Active',
        difficulty: 'Advanced',
        description: 'Multiple instances serve traffic simultaneously across zones/regions.',
        overview: 'Active-active configurations have multiple nodes serving traffic simultaneously. Better resource utilization and faster failover, but requires conflict resolution for writes. Essential for global availability and zero-downtime deployments.',
        learn: [
          'Design global traffic routing and conflict resolution.',
          'Handle regional degradation with graceful isolation.',
          'Understand data synchronization: async replication, CRDTs, operational transformation.',
          'Study split-brain prevention: consensus groups, tie-breaker nodes.',
        ],
        apply: [
          'Use active-active for read-heavy workloads with localized writes (user data in region).',
          'Implement conflict-free replicated data types (CRDTs) for collaborative editing.',
        ],
      }),
      topic({
        id: 'layer-4-load-balancing',
        title: 'Layer 4 Load Balancing',
        difficulty: 'Intermediate',
        description: 'Routes based on transport attributes like IP and port.',
        overview: 'Layer 4 (Transport layer) load balancing uses TCP/UDP connection information. Faster than Layer 7 (no packet inspection), but less flexible. Suitable for long-lived connections, gaming, and video streaming.',
        learn: [
          'Understand high performance connection-level balancing.',
          'Know visibility limits compared to application-aware routing.',
          'Study NAT-based vs DSR (Direct Server Return) modes.',
          'Learn about connection draining and graceful shutdown.',
        ],
        apply: [
          'Use Layer 4 load balancers for TCP-based databases (PostgreSQL, MySQL) and gaming servers.',
          'Implement DSR to reduce load balancer bandwidth for video streaming.',
        ],
      }),
      topic({
        id: 'layer-7-load-balancing',
        title: 'Layer 7 Load Balancing',
        difficulty: 'Intermediate',
        description: 'Routes based on HTTP attributes like path, headers, and cookies.',
        overview: 'Layer 7 (Application layer) load balancing inspects HTTP requests. Enables path-based routing, SSL termination, compression, and request modification. Essential for microservices and API gateways.',
        learn: [
          'Implement path-based and canary routing patterns.',
          'Use rate limiting and auth checks at the edge.',
          'Understand SSL/TLS termination, certificate management, and HTTP/2.',
          'Study WebSocket upgrade handling and sticky sessions.',
        ],
        apply: [
          'Route /api/* to microservices and /* to static content servers.',
          'Implement canary deployments: route 5% traffic to new version based on user ID hash.',
        ],
      }),
      topic({
        id: 'horizontal-scaling',
        title: 'Horizontal Scaling',
        difficulty: 'Basic',
        description: 'Scale out by adding more nodes instead of bigger machines.',
        overview: 'Horizontal scaling adds more commodity servers to handle load. More cost-effective at scale and eliminates single points of failure. Requires stateless application design and data partitioning strategies.',
        learn: [
          'Understand statelessness, partitioning, and distributed coordination.',
          'Predict scaling ceilings from shared dependencies.',
          'Study auto-scaling: reactive (metrics-based) vs predictive (ML-based).',
          'Learn about scale-out databases: Cassandra, DynamoDB, MongoDB sharding.',
        ],
        apply: [
          'Design stateless services: store session in Redis, not local memory.',
          'Use consistent hashing for cache sharding to minimize rebalancing on node addition.',
        ],
      }),
      topic({
        id: 'reverse-proxy-web-server',
        title: 'Reverse Proxy (Web Server)',
        difficulty: 'Basic',
        description: 'A reverse proxy terminates connections and forwards requests to backend services.',
        overview: 'Reverse proxies sit between clients and application servers, providing abstraction and control. Handle SSL termination, compression, caching, and request routing. NGINX and Apache are common implementations.',
        learn: [
          'Use reverse proxy features: TLS termination, compression, and caching.',
          'Improve origin protection and consistent routing behavior.',
          'Understand upstream configuration, health checks, and failover.',
          'Study connection pooling and keepalive optimization.',
        ],
        apply: [
          'Configure rate limiting at reverse proxy to protect backend from DDoS.',
          'Use reverse proxy caching for semi-static content (user profiles updated hourly).',
        ],
      }),
      topic({
        id: 'load-balancer-vs-reverse-proxy',
        title: 'Load Balancer vs Reverse Proxy',
        difficulty: 'Basic',
        description: 'Understand overlap and deployment patterns between these components.',
        overview: 'Load balancers focus on traffic distribution across multiple servers. Reverse proxies focus on request handling and origin protection. Modern solutions (NGINX, Envoy, AWS ALB) often combine both functions.',
        learn: [
          'Know when one component can play both roles.',
          'Separate concerns at network layer vs application layer.',
          'Understand deployment patterns: LB -> Reverse Proxy -> App Server.',
          'Study service mesh sidecars: Envoy as both proxy and load balancer.',
        ],
        apply: [
          'Use dedicated load balancers (AWS NLB) for TCP traffic, reverse proxies (NGINX) for HTTP.',
          'Implement layered approach: Global Server Load Balancing (GSLB) -> Regional LB -> Reverse Proxy -> App.',
        ],
      }),
    ],
  },
  {
    id: 'application-architecture',
    title: 'Application Layer Architecture',
    description: 'Service decomposition, coordination, and runtime behavior.',
    topics: [
      topic({
        id: 'application-layer',
        title: 'Application Layer',
        difficulty: 'Basic',
        description: 'Business logic tier responsible for workflows, validation, and orchestration.',
        overview: 'The application layer implements business logic, orchestrating between APIs, databases, and external services. Should be stateless to enable horizontal scaling. Follows patterns like MVC, hexagonal architecture, or clean architecture.',
        learn: [
          'Separate controllers, domain logic, and infrastructure adapters cleanly.',
          'Design for observability and graceful degradation.',
          'Understand dependency injection and inversion of control.',
          'Study domain-driven design: aggregates, entities, value objects, repositories.',
        ],
        apply: [
          'Implement circuit breakers in application layer to handle downstream failures.',
          'Use structured logging with correlation IDs for distributed tracing.',
        ],
      }),
      topic({
        id: 'microservices',
        title: 'Microservices',
        difficulty: 'Intermediate',
        description: 'Split domains into independently deployable services with clear ownership.',
        overview: 'Microservices architecture decomposes applications into small, autonomous services aligned with business capabilities. Enable independent scaling, deployment, and technology choices. Introduce operational complexity and distributed system challenges.',
        learn: [
          'Define service boundaries and avoid chatty cross-service calls.',
          'Apply data ownership and eventual consistency across services.',
          'Understand service mesh: Istio, Linkerd for traffic management.',
          'Study decomposition patterns: strangler fig, branch by abstraction.',
        ],
        apply: [
          'Design bounded contexts: each service owns its data; no shared databases.',
          'Implement Saga pattern for distributed transactions across services.',
        ],
      }),
      topic({
        id: 'service-discovery',
        title: 'Service Discovery',
        difficulty: 'Intermediate',
        description: 'Locate healthy service instances dynamically in distributed environments.',
        overview: 'Service discovery allows services to find and communicate with each other without hardcoded URLs. Essential in dynamic environments where instances scale up/down and fail. Client-side (eureka) vs server-side (AWS Cloud Map) discovery patterns.',
        learn: [
          'Understand client-side vs server-side discovery patterns.',
          'Use heartbeats, registries, and health metadata correctly.',
          'Study consensus-based registries: etcd, Consul, ZooKeeper.',
          'Learn about service mesh discovery: Kubernetes DNS, Istio service registry.',
        ],
        apply: [
          'Implement health checks that test dependencies, not just TCP port.',
          'Use client-side load balancing with periodic registry updates for low latency.',
        ],
      }),
    ],
  },
  {
    id: 'database-systems',
    title: 'Database Systems',
    description: 'Data modeling, scaling methods, and SQL/NoSQL selection.',
    topics: [
      topic({
        id: 'database-overview',
        title: 'Database',
        difficulty: 'Basic',
        description: 'The persistent system of record for transactional and analytical workloads.',
        overview: 'Databases provide durable, structured storage with query capabilities. The foundation of most applications, requiring careful selection based on consistency needs, query patterns, and scale. ACID properties define transactional safety.',
        learn: [
          'Design primary entities and access patterns before picking technology.',
          'Plan backup, restore, and failure recovery from day one.',
          'Understand ACID: Atomicity, Consistency, Isolation, Durability.',
          'Study write-ahead logging (WAL) and checkpointing for durability.',
        ],
        apply: [
          'Choose database based on read/write ratio, consistency requirements, and query complexity.',
          'Implement point-in-time recovery (PITR) for critical databases.',
        ],
      }),
      topic({
        id: 'rdbms',
        title: 'Relational Database Management System (RDBMS)',
        difficulty: 'Basic',
        description: 'Structured schema with ACID transactions and powerful SQL querying.',
        overview: 'RDBMS (PostgreSQL, MySQL, SQL Server) use tables, rows, and SQL. Provide strong consistency, complex joins, and mature tooling. Best for structured data with relationships and transactional requirements.',
        learn: [
          'Model normalized schemas with clear constraints.',
          'Use indexes carefully based on query patterns.',
          'Understand isolation levels: Read Uncommitted, Read Committed, Repeatable Read, Serializable.',
          'Study query optimization: EXPLAIN plans, index types (B-tree, hash, GiST).',
        ],
        apply: [
          'Normalize to 3NF, then denormalize selectively for read performance.',
          'Use covering indexes (index-only scans) to avoid table lookups.',
        ],
      }),
      topic({
        id: 'master-slave-replication',
        title: 'Master-Slave Replication',
        difficulty: 'Intermediate',
        description: 'Primary handles writes while replicas serve reads.',
        overview: 'Master-slave (primary-replica) replication directs writes to a single primary and reads to replicas. Improves read scalability and provides failover. Asynchronous replication risks data loss; synchronous adds latency.',
        learn: [
          'Understand replication lag and read-after-write caveats.',
          'Route consistency-sensitive reads to primary when required.',
          'Study binary log formats: statement-based, row-based, mixed.',
          'Learn about semi-synchronous replication: wait for at least one replica acknowledgment.',
        ],
        apply: [
          'Use read replicas for reporting and analytics to offload primary.',
          'Implement replication lag monitoring and circuit breaker to primary if lag exceeds threshold.',
        ],
      }),
      topic({
        id: 'master-master-replication',
        title: 'Master-Master Replication',
        difficulty: 'Advanced',
        description: 'Multiple writable nodes improve availability but increase conflict complexity.',
        overview: 'Master-master (multi-primary) replication allows writes to multiple nodes. Improves write availability and geographic distribution. Requires conflict detection and resolution; complex to implement correctly.',
        learn: [
          'Choose conflict resolution strategy and write ownership model.',
          'Prevent dual-write anomalies with clear partitioning.',
          'Understand split-brain scenarios and auto-increment offset strategies.',
          'Study Galera Cluster, MySQL Group Replication, and PostgreSQL BDR.',
        ],
        apply: [
          'Use master-master with active-passive configuration: one primary per region, failover only.',
          'Implement conflict detection using vector clocks or last-write-wins with timestamps.',
        ],
      }),
      topic({
        id: 'federation',
        title: 'Federation',
        difficulty: 'Advanced',
        description: 'Split databases by functional domain to reduce contention and improve autonomy.',
        overview: 'Database federation splits databases by service or domain (user DB, order DB, product DB). Each service owns its data, enabling independent scaling and technology choices. Requires handling cross-database queries in application layer.',
        learn: [
          'Design service-level ownership for each federated datastore.',
          'Handle cross-federation queries and reporting flows.',
          'Understand challenges: distributed transactions, joins across databases.',
          'Study Saga pattern for cross-service transactions.',
        ],
        apply: [
          'Federate when single database becomes bottleneck (CPU > 80%, storage > 1TB).',
          'Implement CQRS: separate read models that aggregate data from multiple federated sources.',
        ],
      }),
      topic({
        id: 'sharding',
        title: 'Sharding',
        difficulty: 'Advanced',
        description: 'Partition data horizontally across multiple database nodes.',
        overview: 'Sharding (horizontal partitioning) splits data across multiple databases based on a shard key. Enables unlimited scale but adds complexity for cross-shard queries and rebalancing. Essential for high-scale applications.',
        learn: [
          'Choose shard keys using cardinality and access distribution.',
          'Handle resharding and hotspot mitigation.',
          'Understand sharding strategies: hash-based, range-based, directory-based.',
          'Study consistent hashing for minimizing data movement on resharding.',
        ],
        apply: [
          'Use hash sharding for even distribution; range sharding for range queries.',
          'Implement cross-shard queries in application layer or use federated query engines (Vitess, Citus).',
        ],
      }),
      topic({
        id: 'denormalization',
        title: 'Denormalization',
        difficulty: 'Intermediate',
        description: 'Duplicate data intentionally for read performance and simpler queries.',
        overview: 'Denormalization introduces redundancy to improve read performance and reduce joins. Accepts update anomalies and increased storage for faster queries. Common in NoSQL and read-heavy workloads.',
        learn: [
          'Know update propagation and consistency costs.',
          'Use denormalization only for proven read bottlenecks.',
          'Understand materialized views and their refresh strategies.',
          'Study change data capture (CDC) for keeping denormalized data synchronized.',
        ],
        apply: [
          'Denormalize user profile data into posts table to avoid joins on timeline reads.',
          'Use eventual consistency for denormalized copies; accept temporary staleness.',
        ],
      }),
      topic({
        id: 'sql-tuning',
        title: 'SQL Tuning',
        difficulty: 'Intermediate',
        description: 'Optimize query plans, indexes, and execution patterns for predictable latency.',
        overview: 'SQL tuning improves database performance through index optimization, query rewriting, and schema design. Critical for maintaining low latency as data grows. Requires understanding execution plans and database internals.',
        learn: [
          'Analyze EXPLAIN plans and remove full table scans where possible.',
          'Reduce lock contention and expensive joins on hot paths.',
          'Understand covering indexes, composite indexes, and index selectivity.',
          'Study query plan caching, parameter sniffing, and histogram statistics.',
        ],
        apply: [
          'Add composite indexes for multi-column WHERE clauses, ordering by cardinality.',
          'Use query result caching at application layer for expensive analytical queries.',
        ],
      }),
      topic({
        id: 'nosql',
        title: 'NoSQL',
        difficulty: 'Intermediate',
        description: 'Flexible data stores optimized for scale, availability, or specific access models.',
        overview: 'NoSQL databases sacrifice some relational features (joins, ACID) for horizontal scalability, flexible schemas, or specialized access patterns. Categories: key-value, document, wide-column, graph. Choose based on data shape, not hype.',
        learn: [
          'Understand consistency models and partition behavior per engine.',
          'Pick NoSQL by workload shape, not trend.',
          'Study CAP theorem implications for different NoSQL systems.',
          'Learn about tunable consistency: ONE, QUORUM, ALL in Cassandra.',
        ],
        apply: [
          'Use NoSQL when data is unstructured, relationships are simple, and scale is massive.',
          'Implement polyglot persistence: PostgreSQL for transactions, Redis for cache, Elasticsearch for search.',
        ],
      }),
      topic({
        id: 'key-value-store',
        title: 'Key-Value Store',
        difficulty: 'Intermediate',
        description: 'Simple key lookup model with very high read/write performance.',
        overview: 'Key-value stores (Redis, DynamoDB, Riak) provide O(1) access by primary key. Simplest NoSQL model, offering extreme performance and horizontal scalability. Limited query capabilities; no joins or secondary indexes (unless added).',
        learn: [
          'Use for sessions, counters, feature flags, and ephemeral state.',
          'Model key design and TTL lifecycle.',
          'Understand partitioning strategies: consistent hashing, rendezvous hashing.',
          'Study eviction policies: LRU, LFU, TTL expiration.',
        ],
        apply: [
          'Use Redis for session storage with TTL matching session timeout.',
          'Implement distributed counters with atomic INCR operations.',
        ],
      }),
      topic({
        id: 'document-store',
        title: 'Document Store',
        difficulty: 'Intermediate',
        description: 'JSON-like document model for flexible schema and nested data.',
        overview: 'Document stores (MongoDB, Couchbase, DynamoDB) store semi-structured data as documents. Flexible schema enables rapid iteration. Support nested objects and arrays, with indexing on document fields.',
        learn: [
          'Balance schema flexibility with index discipline.',
          'Avoid oversized documents and unbounded arrays.',
          'Understand sharding in document stores: shard keys, chunks, balancer.',
          'Study aggregation pipelines and map-reduce for analytics.',
        ],
        apply: [
          'Use document stores for product catalogs where attributes vary by category.',
          'Limit document size to 16MB (MongoDB limit) and avoid deeply nested arrays.',
        ],
      }),
      topic({
        id: 'wide-column-store',
        title: 'Wide Column Store',
        difficulty: 'Advanced',
        description: 'Column-family model optimized for large-scale writes and time-series patterns.',
        overview: 'Wide-column stores (Cassandra, HBase, Bigtable) store data in columns rather than rows, optimized for write-heavy workloads and time-series data. Excellent for IoT, logging, and messaging at massive scale.',
        learn: [
          'Design partition and clustering keys for query-first modeling.',
          'Prevent hotspotting with key distribution strategy.',
          'Understand LSM-tree storage: memtables, SSTables, compaction.',
          'Study tunable consistency and anti-entropy repair.',
        ],
        apply: [
          'Use Cassandra for time-series data: partition key = device_id, clustering key = timestamp.',
          'Implement bucketing (device_id + date) to prevent unbounded partition growth.',
        ],
      }),
      topic({
        id: 'graph-database',
        title: 'Graph Database',
        difficulty: 'Intermediate',
        description: 'Store entities and relationships for traversal-heavy workloads.',
        overview: 'Graph databases (Neo4j, Amazon Neptune, ArangoDB) optimize for relationship traversal. Use nodes, edges, and properties. Excel at finding paths, recommendations, and pattern matching. Poor for aggregate queries.',
        learn: [
          'Use for recommendation, fraud detection, and social relationships.',
          'Understand traversal complexity and index support.',
          'Study graph query languages: Cypher, Gremlin, SPARQL.',
          'Learn about graph algorithms: shortest path, PageRank, community detection.',
        ],
        apply: [
          'Use graph databases for 3+ level relationship queries (friends-of-friends-of-friends).',
          'Implement real-time recommendation engines using graph traversals.',
        ],
      }),
      topic({
        id: 'sql-or-nosql',
        title: 'SQL or NoSQL',
        difficulty: 'Basic',
        description: 'Choose based on access pattern, consistency needs, and team operation model.',
        overview: 'SQL vs NoSQL is not a binary choice but a spectrum. SQL offers ACID, joins, and maturity. NoSQL offers scale, flexibility, and performance. Most modern applications use both (polyglot persistence).',
        learn: [
          'Use a requirements matrix instead of ideological preferences.',
          'Accept polyglot persistence when workload needs differ.',
          'Understand NewSQL: CockroachDB, Google Spanner (SQL + horizontal scale).',
          'Study CAP theorem implications for your specific use case.',
        ],
        apply: [
          'Start with SQL (PostgreSQL) until you hit specific scalability limits.',
          'Add NoSQL components for specific needs: Redis for cache, Elasticsearch for search, Cassandra for time-series.',
        ],
      }),
    ],
  },
  {
    id: 'caching-patterns',
    title: 'Caching Deep Dive',
    description: 'Caching layers, invalidation strategies, and write policies.',
    topics: [
      topic({
        id: 'cache-overview',
        title: 'Cache',
        difficulty: 'Basic',
        description: 'Temporary fast storage used to reduce latency and origin load.',
        overview: 'Caching stores copies of frequently accessed data in fast storage (RAM, SSD). Reduces database load, improves response times, and increases availability during outages. Trade-off: complexity of consistency and invalidation.',
        learn: [
          'Define cache hit rate, miss penalty, and eviction behavior.',
          'Treat cache as optimization, not the source of truth.',
          'Understand cache coherence and consistency models.',
          'Study cache warming and cold start problems.',
        ],
        apply: [
          'Target 95%+ cache hit rate for hot data; monitor and optimize miss patterns.',
          'Implement cache-aside for read-heavy workloads; write-through for consistency.',
        ],
      }),
      topic({
        id: 'client-caching',
        title: 'Client Caching',
        difficulty: 'Basic',
        description: 'Store responses near the user in browser or mobile layers.',
        overview: 'Client caching stores responses in browser cache (HTTP cache) or mobile local storage. Fastest possible access (no network), but hardest to invalidate. Controlled via HTTP headers.',
        learn: [
          'Use ETag, Cache-Control, and stale-while-revalidate semantics.',
          'Handle versioned assets and invalidation safely.',
          'Understand browser cache storage limits and eviction.',
          'Study Service Workers for offline-first applications.',
        ],
        apply: [
          'Set Cache-Control: immutable for versioned JS/CSS files with hashed filenames.',
          'Use localStorage/IndexedDB for offline app data with sync-on-reconnect.',
        ],
      }),
      topic({
        id: 'cdn-caching',
        title: 'CDN Caching',
        difficulty: 'Basic',
        description: 'Edge caching for static and selective dynamic content.',
        overview: 'CDN caching places content at edge locations worldwide. Reduces latency and origin load. Can cache static assets and, with edge compute, dynamic content. Purging is slower than application cache.',
        learn: [
          'Design cache keys, vary headers, and purge strategy.',
          'Protect origin with shield POP and request coalescing.',
          'Understand TTL hierarchies: origin TTL vs CDN TTL vs browser TTL.',
          'Study dynamic content acceleration (DCA) and edge side includes (ESI).',
        ],
        apply: [
          'Cache API responses at CDN with short TTL (30s) for semi-dynamic content.',
          'Use surrogate keys for fine-grained cache invalidation.',
        ],
      }),
      topic({
        id: 'web-server-caching',
        title: 'Web Server Caching',
        difficulty: 'Intermediate',
        description: 'Cache responses at reverse proxy/web server layer to offload app servers.',
        overview: 'Web server caching (NGINX, Varnish) stores responses at the reverse proxy layer. Faster than application cache, handles more load. Limited to cacheable HTTP responses.',
        learn: [
          'Cache safe endpoints and use bypass rules for personalized data.',
          'Monitor stale/expired behavior under bursts.',
          'Understand microcaching: very short TTL (1s) for high-traffic endpoints.',
          'Study cache locking to prevent thundering herd.',
        ],
        apply: [
          'Enable open_file_cache in NGINX for static file serving.',
          'Use proxy_cache with 1-second TTL for high-read API endpoints.',
        ],
      }),
      topic({
        id: 'database-caching',
        title: 'Database Caching',
        difficulty: 'Intermediate',
        description: 'Reduce repeated database reads via dedicated cache tiers.',
        overview: 'Database caching (Redis, Memcached) sits between application and database. Stores query results, objects, or sessions. Most flexible caching layer but requires application integration.',
        learn: [
          'Identify high-read keys and expensive query result sets.',
          'Prevent thundering herd with locking or request collapsing.',
          'Understand cache stampede mitigation: probabilistic early expiration.',
          'Study write-through vs write-behind impact on cache consistency.',
        ],
        apply: [
          'Cache user sessions in Redis with TTL matching session timeout.',
          'Implement cache-aside with "cache stampede" protection using mutex locks.',
        ],
      }),
      topic({
        id: 'application-caching',
        title: 'Application Caching',
        difficulty: 'Intermediate',
        description: 'Cache computed objects and business-level responses in the app layer.',
        overview: 'Application caching stores deserialized objects in application memory. Fastest server-side cache (no network). Limited by application server memory and requires restart on deployment.',
        learn: [
          'Choose key schema that includes tenant and version dimensions.',
          'Set TTL based on freshness requirements.',
          'Understand on-heap vs off-heap caching (Ehcache, Caffeine).',
          'Study cache size limits and eviction impact on GC.',
        ],
        apply: [
          'Use Caffeine for in-process caching with automatic size-based eviction.',
          'Implement multi-level cache: L1 (in-app) → L2 (Redis) → L3 (Database).',
        ],
      }),
      topic({
        id: 'database-query-level-caching',
        title: 'Caching at the Database Query Level',
        difficulty: 'Intermediate',
        description: 'Cache full query outputs for repeated read-heavy patterns.',
        overview: 'Query-level caching stores complete query results. Useful for expensive analytical queries or complex joins. Invalidation is coarse (any table change invalidates dependent queries).',
        learn: [
          'Use query hash keys and invalidation on data mutation.',
          'Know when query-level cache becomes too coarse.',
          'Understand MySQL Query Cache (deprecated) vs application-level query caching.',
          'Study materialized views for pre-computed query results.',
        ],
        apply: [
          'Cache expensive aggregation queries (daily revenue reports) with 1-hour TTL.',
          'Use application-level query caching with fine-grained dependency tracking.',
        ],
      }),
      topic({
        id: 'object-level-caching',
        title: 'Caching at the Object Level',
        difficulty: 'Intermediate',
        description: 'Cache domain objects keyed by ID for granular invalidation.',
        overview: 'Object-level caching stores individual entities (User, Product) by primary key. Fine-grained invalidation: update User #123 only invalidates that cache entry. Most common caching pattern for OLTP workloads.',
        learn: [
          'Build cache keys around object identity and schema versions.',
          'Use partial cache population for large entities.',
          'Understand serialization costs: JSON, Protocol Buffers, Kryo.',
          'Study cache warming strategies for predictable loads.',
        ],
        apply: [
          'Cache user objects as JSON in Redis with key user:{id}.',
          'Implement write-through caching: update DB and cache in single transaction.',
        ],
      }),
      topic({
        id: 'when-to-update-the-cache',
        title: 'When to Update the Cache',
        difficulty: 'Intermediate',
        description: 'Choose invalidation and write timing based on freshness and load.',
        overview: 'Cache update timing affects consistency, performance, and complexity. Options: update on write (write-through), update on read (cache-aside), or background refresh. Each has trade-offs in consistency and resource usage.',
        learn: [
          'Balance stale-read risk against write amplification.',
          'Treat cache invalidation as a first-class design concern.',
          'Understand race conditions between cache and database updates.',
          'Study cache warming vs cache-aside vs refresh-ahead.',
        ],
        apply: [
          'Use TTL-based expiration for non-critical data; explicit invalidation for critical data.',
          'Implement "dog-piling" protection using locks during cache miss.',
        ],
      }),
      topic({
        id: 'cache-aside',
        title: 'Cache-Aside',
        difficulty: 'Basic',
        description: 'Application reads cache first, then database on miss, then fills cache.',
        overview: 'Cache-aside (lazy loading) is the most common pattern. Application checks cache; on miss, queries database and populates cache. Simple, but vulnerable to thundering herd on cache miss.',
        learn: [
          'Simple and common pattern with explicit control by application.',
          'Requires careful invalidation and miss handling.',
          'Understand thundering herd problem and mitigation strategies.',
          'Study cache warming to prevent cold start issues.',
        ],
        apply: [
          'Implement with try-lock pattern: only one thread loads from DB on cache miss.',
          'Use cache-aside for user profiles, product details, and configuration.',
        ],
      }),
      topic({
        id: 'write-through',
        title: 'Write-Through',
        difficulty: 'Intermediate',
        description: 'Write to cache and backing store synchronously for consistency.',
        overview: 'Write-through updates cache and database in the same operation. Ensures cache consistency but increases write latency. Best for read-heavy workloads with strong consistency requirements.',
        learn: [
          'Improves read freshness but increases write latency.',
          'Useful when read-after-write consistency matters.',
          'Understand write amplification: every write updates both cache and DB.',
          'Study write coalescing to reduce database write pressure.',
        ],
        apply: [
          'Use for user session data where consistency between cache and DB is critical.',
          'Combine with cache-aside reads for best performance.',
        ],
      }),
      topic({
        id: 'write-behind-write-back',
        title: 'Write-Behind (Write-Back)',
        difficulty: 'Advanced',
        description: 'Acknowledge writes after cache update; persist asynchronously to database.',
        overview: 'Write-behind acknowledges writes immediately to cache, then asynchronously writes to database. Lowest write latency but risk of data loss on cache failure. Requires durable write queue.',
        learn: [
          'Lower write latency with durability trade-offs.',
          'Needs queue durability and replay for crash recovery.',
          'Understand write coalescing: batching multiple writes to reduce DB load.',
          'Study crash recovery: replaying write queue after failure.',
        ],
        apply: [
          'Use for high-write counters and analytics where temporary loss is acceptable.',
          'Implement durable write-ahead log (WAL) in cache layer for crash recovery.',
        ],
      }),
      topic({
        id: 'refresh-ahead',
        title: 'Refresh-Ahead',
        difficulty: 'Advanced',
        description: 'Proactively refresh hot keys before expiration to reduce misses.',
        overview: 'Refresh-ahead automatically reloads cached data before it expires, based on access patterns. Eliminates latency spikes from cache misses on hot data. Requires prediction of which keys will be accessed.',
        learn: [
          'Use access frequency to schedule refresh jobs intelligently.',
          'Prevent over-refreshing cold or low-value keys.',
          'Understand prediction algorithms: LRU, LFU, access pattern analysis.',
          'Study coordination: prevent multiple servers refreshing same key simultaneously.',
        ],
        apply: [
          'Implement for predictable hot data: trending products, popular articles.',
          'Use probabilistic early expiration: refresh when TTL < random threshold based on access frequency.',
        ],
      }),
    ],
  },
  {
    id: 'async-communication-security',
    title: 'Asynchronism, Communication, and Security',
    description: 'Core communication protocols and resilience controls in distributed systems.',
    topics: [
      topic({
        id: 'asynchronism',
        title: 'Asynchronism',
        difficulty: 'Basic',
        description: 'Decouple request lifecycle from long-running processing paths.',
        overview: 'Asynchronous processing separates request acceptance from processing. Improves responsiveness, isolates failures, and smooths traffic spikes. Essential for scalable distributed systems.',
        learn: [
          'Use async flows to improve responsiveness and isolate spikes.',
          'Design retry-safe idempotent operations.',
          'Understand event-driven architecture: events vs commands.',
          'Study backpressure and flow control mechanisms.',
        ],
        apply: [
          'Use message queues for email sending, image processing, and report generation.',
          'Implement async payment processing: accept immediately, process in background, notify when complete.',
        ],
      }),
      topic({
        id: 'message-queues',
        title: 'Message Queues',
        difficulty: 'Intermediate',
        description: 'Durable queues enable decoupled producers and consumers.',
        overview: 'Message queues (Kafka, RabbitMQ, SQS) buffer messages between services. Provide durability, ordering guarantees, and load leveling. Enable event-driven architectures and microservice communication.',
        learn: [
          'Understand delivery semantics: at-most-once, at-least-once, effectively-once.',
          'Handle poison messages and dead-letter queues.',
          'Study partitioning: ordering guarantees vs parallelism.',
          'Learn about consumer groups and load balancing.',
        ],
        apply: [
          'Use Kafka for high-throughput event streaming; RabbitMQ for complex routing.',
          'Implement idempotent consumers to handle at-least-once delivery duplicates.',
        ],
      }),
      topic({
        id: 'task-queues',
        title: 'Task Queues',
        difficulty: 'Intermediate',
        description: 'Background job execution for non-blocking workloads.',
        overview: 'Task queues (Celery, Bull, Sidekiq) manage background job execution. Handle retries, scheduling, and priority. Essential for offloading work from request path.',
        learn: [
          'Model retries with backoff and max attempt limits.',
          'Control concurrency per worker and task type.',
          'Understand job serialization and result storage.',
          'Study delayed jobs and cron-like scheduling.',
        ],
        apply: [
          'Use task queues for image resizing, PDF generation, and third-party API calls.',
          'Implement exponential backoff with jitter to prevent thundering herd on retries.',
        ],
      }),
      topic({
        id: 'back-pressure',
        title: 'Back Pressure',
        difficulty: 'Advanced',
        description: 'Protect systems by slowing producers when consumers are saturated.',
        overview: 'Back pressure prevents cascade failures by signaling upstream to slow down when downstream cannot keep up. Essential for stability in high-throughput systems.',
        learn: [
          'Apply bounded queues, token buckets, and load shedding.',
          'Expose overload signals for graceful client behavior.',
          'Understand TCP flow control as back pressure example.',
          'Study reactive streams: ReactiveX, Project Reactor backpressure modes.',
        ],
        apply: [
          'Implement bounded queues: reject new tasks when queue exceeds threshold.',
          'Use TCP backpressure naturally in streaming systems; implement explicit backpressure in HTTP APIs.',
        ],
      }),
      topic({
        id: 'communication-overview',
        title: 'Communication',
        difficulty: 'Basic',
        description: 'Transport and API protocols define reliability, speed, and developer ergonomics.',
        overview: 'Inter-service communication choices impact latency, reliability, and system coupling. Synchronous (HTTP/gRPC) vs asynchronous (message queues). Each has appropriate use cases.',
        learn: [
          'Separate transport protocol choice from API style choice.',
          'Evaluate observability and debugging needs for each option.',
          'Understand synchronous vs asynchronous communication trade-offs.',
          'Study service mesh: Istio, Linkerd for communication abstraction.',
        ],
        apply: [
          'Use synchronous for user-facing operations requiring immediate response.',
          'Use asynchronous for cross-service updates that can be eventually consistent.',
        ],
      }),
      topic({
        id: 'tcp',
        title: 'Transmission Control Protocol (TCP)',
        difficulty: 'Basic',
        description: 'Connection-oriented protocol with reliability and ordered delivery.',
        overview: 'TCP provides reliable, ordered, error-checked delivery. Foundation of HTTP and most internet protocols. Connection-oriented with congestion control and flow control.',
        learn: [
          'Know handshake, retransmission, and flow control fundamentals.',
          'Understand impact of head-of-line blocking and congestion control.',
          'Study TCP tuning: Nagle\'s algorithm, TCP_NODELAY, window scaling.',
          'Learn about connection pooling and keepalive optimization.',
        ],
        apply: [
          'Use TCP for reliable data transfer; disable Nagle\'s algorithm for low-latency applications.',
          'Implement connection pooling to avoid TCP handshake overhead.',
        ],
      }),
      topic({
        id: 'udp',
        title: 'User Datagram Protocol (UDP)',
        difficulty: 'Basic',
        description: 'Connectionless protocol with low overhead and no delivery guarantees.',
        overview: 'UDP provides fast, connectionless transmission without reliability guarantees. Used where speed matters more than accuracy: video streaming, gaming, DNS, telemetry.',
        learn: [
          'Use where timeliness matters more than perfect reliability.',
          'Implement app-level reliability if required.',
          'Understand packet loss and ordering issues.',
          'Study QUIC: UDP-based protocol with TCP-like reliability.',
        ],
        apply: [
          'Use UDP for real-time video streaming, online gaming, and IoT telemetry.',
          'Implement application-level sequence numbers and acknowledgments if needed.',
        ],
      }),
      topic({
        id: 'rpc',
        title: 'Remote Procedure Call (RPC)',
        difficulty: 'Intermediate',
        description: 'Call remote services with typed contracts and efficient serialization.',
        overview: 'RPC (gRPC, Thrift, Avro) abstracts network calls as local function calls. Efficient binary serialization (Protocol Buffers), strong typing, and streaming support. Popular for internal service communication.',
        learn: [
          'Use deadlines, retries, and circuit breakers in client libraries.',
          'Version APIs to preserve compatibility.',
          'Understand HTTP/2 multiplexing and streaming.',
          'Study service mesh integration with RPC.',
        ],
        apply: [
          'Use gRPC for inter-service communication with strict contracts.',
          'Implement client-side load balancing and health checking.',
        ],
      }),
      topic({
        id: 'rest',
        title: 'Representational State Transfer (REST)',
        difficulty: 'Basic',
        description: 'Resource-oriented HTTP APIs with broad interoperability.',
        overview: 'REST uses HTTP verbs (GET, POST, PUT, DELETE) on resource URLs. Stateless, cacheable, and universally supported. Best for public APIs and browser clients.',
        learn: [
          'Design clean resource naming and consistent response semantics.',
          'Use pagination, filtering, and caching headers effectively.',
          'Understand HATEOAS and Richardson Maturity Model.',
          'Study OpenAPI/Swagger for API documentation.',
        ],
        apply: [
          'Use REST for public APIs and third-party integrations.',
          'Implement pagination with cursor-based (not offset) for large datasets.',
        ],
      }),
      topic({
        id: 'security',
        title: 'Security',
        difficulty: 'Intermediate',
        description: 'Security is a design requirement, not a post-launch patch.',
        overview: 'Security must be designed into systems from the start. Covers authentication, authorization, encryption, secrets management, and audit logging. Defense in depth at every layer.',
        learn: [
          'Cover authn/authz, encryption in transit/at rest, and secret management.',
          'Rate-limit abuse paths and audit sensitive actions.',
          'Understand OWASP Top 10 and common attack vectors.',
          'Study zero-trust architecture: verify every request, trust no network.',
        ],
        apply: [
          'Implement TLS 1.3 for all external and internal communications.',
          'Use JWT with short expiry for stateless auth; refresh tokens for extended sessions.',
        ],
      }),
    ],
  },
  {
    id: 'appendix-resources',
    title: 'Appendix and Knowledge Expansion',
    description: 'Reference tables, interview expansion topics, and architecture reading.',
    topics: [
      topic({
        id: 'appendix',
        title: 'Appendix',
        difficulty: 'Basic',
        description: 'Quick-reference material for estimation and interview prep.',
        overview: 'Appendix contains reference data for quick calculations: latency numbers, storage sizes, throughput estimates. Essential for back-of-envelope calculations in interviews.',
        learn: [
          'Use appendix references to speed up mental math and trade-off analysis.',
          'Pair reference data with architecture reasoning, not memorization alone.',
          'Understand orders of magnitude: L1 cache vs RAM vs SSD vs network.',
          'Study capacity planning: QPS per server, storage growth rates.',
        ],
        apply: [
          'Memorize key numbers: 1ms for L2 cache, 100ms for cross-country network.',
          'Use reference numbers to justify sharding decisions: "At 10k QPS per shard, we need 100 shards for 1M QPS."',
        ],
      }),
      topic({
        id: 'powers-of-two-table',
        title: 'Powers of Two Table',
        difficulty: 'Basic',
        description: 'Memorize storage and memory scale references for quick estimations.',
        overview: 'Powers of two are fundamental to computer science: memory sizes, hash tables, and addressing. Quick mental conversion between binary prefixes (KiB, MiB) and decimal (KB, MB) is essential.',
        learn: [
          'Know KB/MB/GB/TB conversions in powers of two.',
          'Use fast estimation shortcuts during interview whiteboarding.',
          'Understand binary prefixes: KiB (1024) vs KB (1000).',
          'Study address space limitations: 32-bit (4GB) vs 64-bit (exabytes).',
        ],
        apply: [
          'Quickly estimate: 2^10 = 1K, 2^20 = 1M, 2^30 = 1G.',
          'Calculate hash table sizes: next power of two for efficient modulo operations.',
        ],
      }),
      topic({
        id: 'latency-numbers-every-programmer-should-know',
        title: 'Latency Numbers Every Programmer Should Know',
        difficulty: 'Basic',
        description: 'Internalize network, memory, and disk latency orders of magnitude.',
        overview: 'Jeff Dean\'s latency numbers provide intuition for system performance. Understanding that L1 cache access is 1ns while disk seek is 10ms helps make appropriate optimization decisions.',
        learn: [
          'Compare L1 cache vs RAM vs SSD vs cross-region network latency.',
          'Translate latency budgets into practical architecture decisions.',
          'Understand relative costs: memory is 1000x faster than SSD, 100000x faster than network.',
          'Study how these numbers change over time (network improves faster than disk).',
        ],
        apply: [
          'Design for memory access patterns; minimize random disk I/O.',
          'Budget latency: if p99 must be 100ms, you have budget for 10ms DB query + 50ms network + 40ms processing.',
        ],
      }),
      topic({
        id: 'additional-system-design-interview-questions',
        title: 'Additional System Design Interview Questions',
        difficulty: 'Intermediate',
        description: 'Expand practice breadth beyond the initial question set.',
        overview: 'Practice with diverse problem types to build pattern recognition. Each problem reinforces different architectural concepts: consistency, scalability, availability, or performance.',
        learn: [
          'Practice framing assumptions quickly in the first 2-3 minutes.',
          'Re-solve the same problem under different scale or consistency constraints.',
          'Study classic problems: URL shortener, Twitter, Uber, WhatsApp, Typeahead.',
          'Understand patterns: read-heavy vs write-heavy, geo-distributed vs single-region.',
        ],
        apply: [
          'Use the Practice section to simulate timed interview rounds and write one trade-off summary after each question.',
          'Practice explaining your design to a peer; teaching reveals gaps in understanding.',
        ],
      }),
      topic({
        id: 'real-world-architectures',
        title: 'Real World Architectures',
        difficulty: 'Intermediate',
        description: 'Study production architecture case studies to understand practical constraints.',
        overview: 'Real systems face constraints not present in interview questions: legacy code, organizational boundaries, budget limits, and regulatory requirements. Studying real architectures provides grounding.',
        learn: [
          'Observe migration stories, incidents, and scaling bottlenecks.',
          'Compare ideal interview designs vs real operational compromises.',
          'Study post-mortems: what failed and why.',
          'Understand evolution: how architectures change as companies grow.',
        ],
        apply: [
          'Read engineering blogs from Netflix, Uber, Airbnb, and Dropbox.',
          'Analyze how designs changed from startup (monolith) to scale (microservices).',
        ],
      }),
      topic({
        id: 'company-architectures',
        title: 'Company Architectures',
        difficulty: 'Intermediate',
        description: 'Analyze how different companies model similar problems differently.',
        overview: 'Different companies solve similar problems with different constraints. Netflix prioritizes availability; banks prioritize consistency. Understanding these variations builds design flexibility.',
        learn: [
          'Contrast architecture choices by company size and product requirements.',
          'Identify reusable patterns across domains.',
          'Study domain-specific solutions: gaming (low latency), finance (consistency), social (scale).',
          'Understand organizational impact on architecture (Conway\'s Law).',
        ],
        apply: [
          'Compare Twitter (fan-out-on-write) vs Facebook (fan-out-on-read) for news feeds.',
          'Analyze why Uber uses Kafka for events but Cassandra for locations.',
        ],
      }),
      topic({
        id: 'company-engineering-blogs',
        title: 'Company Engineering Blogs',
        difficulty: 'Basic',
        description: 'Use engineering blogs for current patterns, reliability lessons, and tooling insights.',
        overview: 'Engineering blogs provide current, practical insights into real system challenges. More valuable than textbooks for modern distributed systems patterns and lessons from failures.',
        learn: [
          'Track architecture evolution over time instead of single snapshots.',
          'Focus on incident write-ups and trade-off discussions.',
          'Follow blogs: Netflix Tech Blog, Uber Engineering, Airbnb Engineering, Cloudflare Blog.',
          'Study conference talks: QCon, Strange Loop, AWS re:Invent.',
        ],
        apply: [
          'Subscribe to 3-5 engineering blogs; read one article weekly.',
          'Summarize lessons learned: what failed, what worked, what would you do differently.',
        ],
      }),
    ],
  },
];
